# Lists

This chapter covers an additional R data type called lists. Lists are
somewhat similar to atomic vectors (they are "generalized vectors"!),
but can store more types of data and more details _about_ that data
(with some cost).  Lists are another way to create R's version of a
**Map** data structure, a common and extremely useful way of organizing data in a computer program. Moreover: lists are used to create _data frames_, which is the primary data storage type used for working with sets of real data in R. This chapter will cover how to create and access elements in a list, as well as how to apply functions to lists or vectors.

## What is a List?

A **List** is a lot like an atomic vector, in that it is a
_one-dimensional ordered positional collection of data_.  Exaclyt as in
case of atomic vectors, list elements preserve their order, and they
have a well-defined position in the list.  However, lists have a few major differences from vectors:

1. Unlike a vector, you can store elements of _different types_ in a
list: e.g., a list can contain numeric data _and_ character string data,
functions, and even other lists.

2. Because lists can contain any type of data, they are much less efficient
as vectors.  The vectorized operations that can handle atomic vectors on
the fly usually fail in case of lists.  Hence one should prefer atomic
vectors over lists if possible.

3. Elements in a list can also be named, but unlike in case of vector,
there exists a convenient shorthand `$`-construct to extract named elements from lists.

Lists are extremely useful for organizing data. They allow you to group together data like a person's name (characters), job title (characters), salary (number), and whether they are in a union (logical)&mdash;and you don't have to remember whether whether the person's name or title was the first element!

## Creating Lists

You create a list by using the `list()` function and passing it any number of **arguments** (separated by commas) that you want to make up that list&mdash;similar to the `c()` functon for vectors.

However, if your list contains heterogenous elements, it is usually a
good idea to specify the _tags_ for each element in the list in the same
way you can give names to vector elements in `c()`&mdash;by putting the name tag (which is like a variable name), followed by an equal symbol (**`=`**), followed by the value you want to go in the list and be associated with that tag. For example:

```r
person <- list(first_name = "Ada", job = "Programmer", salary = 78000,
               in_union = TRUE)
person
## person
## $first_name
## [1] "Ada"
## 
## $job
## [1] "Programmer"
## 
## $salary
## [1] 78000
## 
## $in_union
## [1] TRUE
```

This creates a list of 4 elements: `"Ada"` which is tagged with
`first_name`, `"Programmer"` which is tagged with `job`, `78000` which
is tagged with `salary`, and `TRUE` which is tagged with `in_union`.
The output lists all component names following the dollar sign `$` (more
about it below), and prints the components themselves right after the names.

- Note that you can have _vectors_ as elements of a list. In fact, each
  of these scalar values are really vectors (of length 1) as indicated
  by `[1]` preceeding their values!

- The use of the `=` symbol here is an example of assigning a value to a specific named argument. You can actually use this syntax for _any_ function (e.g., rather than listing arguments in order, you can explicit "assign" a value to each argument), but it is more common to just use the normal order of the arguments if there aren't very many.

It is possible to create a list without tagging the elements and assign
names later:

```r
person_alt <- list("Ada", 78000, TRUE)
person_alt

## [[1]]
## [1] "Ada"
## 
## [[3]]
## [1] 78000
## 
## [[4]]
## [1] TRUE

names(person_alt) <- c("name", "income", "memebership")
person_alt

## $name
## [1] "Ada"
## 
## $income
## [1] 78000
## 
## $memebership
## [1] TRUE
```

Note that the name tags are missing before we assign names, instead of
names we see the position of the components in double brackets like
`[[1]]` (more about it below).

Making name-less lists and assigning names later is usually more error-prone and harder way to make lists
manually, but when you automatically create lists in your code, it is a
good alternative.

Finally, empty lists of given lenth can also be created using the
general `vector()` function.  For instance, `vector("list", 5)`, creates
a list of five `NULL` elements.  This is a good approach if you are
updating the list later.


## Accessing List Elements

There are four ways to access elements in lists.  Three of these reflect
atomic vector indexing, the `$`-construct is unique for lists.  However, there
are important differences.


### Indexing by position

You can always access list elements by their position.  It is in many
ways verys similar to that of atomic vectors with one major caveat:
indexing with single brackets will extract not the components but a _sublist_ that
contains just those components:
```{r, eval=FALSE}
# note: this list is not not an atomic vector, even though elements have the same types
animals <- list("Aardvark", "Baboon", "Camel")
animals[c(1,3)]

## [[1]]
## [1] "Aardvark"
## 
## [[2]]
## [1] "Camel"
```

You can see that the result is a list with two components, "Aardvark"
and "Camel", picked from the the positions 1 and 3 in the original list.

The fact that single brackets returns a list in case of vector is
actually a smart design choice.  First, it cannot return a vector in
general&mdash;the requested components may be of different type and
simply not fit into an atomic vector.  Second, single-bracket indexing
in case of vectors actually returns a _subvector_.  We just tend to
overlook that a "scalar" is actually a length-1 vector.  But however
smart this design decision may look, people tend to learn it in the hard
way.  When confronted with weird errors, check that what you think
should be a vector is in fact a vector and not a list.

The good news is that there is an easy way to extract components.  A
single element, and not just a length-one-sublist, is extracted by
double brackets.  For instance,
```{r, eval=FALSE}
animals[[2]]

## [1] "Baboon"
```
returns a length-1 character vector.

Unfortunately, the good news end here.  You can extract individual
elements in this way, but you cannot get a vector of individual list
components: `animals[[1:2]]` will give you _subscript out of bounds_.
As above, this is a design choice: as list components may be of
different type, you may not be able to mold these into a single vector.

<p class="alert alert-note>
There are ways to merge components into a vector, given they are of the
same type.  For instance `Reduce(c, animals)` will convert the animals
into a vector of suitable type.  Ditto with `as.character(animals)`.
</p>


### Indexing by Name

If the list is named, one can use a character vector to extract it's
components, exacly in the same way as we used the numeric positions
above.  For instance

```r
person <- list(first_name = "Bob", last_name = "Wong", salary = 77000, in_union = TRUE)

person[c("first_name", "salary")]

## $first_name
## [1] "Bob"
## 
## $salary
## [1] 77000

person[["first_name"]]  # [1] "Bob"
person[["salary"]]  # [1] 77000
```

As in case of positional indexing, single brackets return a sublist
while double brackets return the corresponding component itself.


### Indexing by Logical vector

Finally, as in case of atomic vectors, we can use logical indices with
lists too.  There are a few differences though:

* one can only extract sublists, not individual components.
  `person[c(TRUE, TRUE, FALSE, FALSE)]` will give you a sublist with
  first and last name.  `person[[c(TRUE, FALSE, FALSE, FALSE)]]` will
  fail.
* many operators are vectorized but they are not "listified".  You
  cannot use operators like `>` or `+` for comparing lists.  Hence the
  powerful logical indexing operations like `x[x > 0]` are not possible
  with lists.  This substantially reduces the potential usage cases of
  logical indexing for lists.

For instance, we can extract all components of certain name from the
list:
```{r, eval=FALSE}
planes <- list("Airbus 380"=c(seats=575, speed=0.85),
               "Boeing 787"=c(seats=290, speed=0.85),
               "Airbus 350"=c(seats=325, speed=0.85))
                           # cruise speed, Mach
planes[startsWith(names(planes), "Airbus")]
## $`Airbus 380`
##  seats  speed 
## 575.00   0.85 
## 
## $`Airbus 350`
##  seats  speed 
## 325.00   0.85 
```


#### Single vs. Double Brackets
<p class="alert alert-warning">**Watch out!**: vectors use ___single___-bracket notation for accessing by index, but lists use ___double___-bracket notation for accessing by index!</p>

This is because the single-bracket syntax for vectors isn't actually selecting by index: rather it is **filtering** by whatever vector is inside the brackets (which may be just a single element: the index number to extract). In R, single brackets _always_ mean to filter the collection. So if you put single-brackets after a list, what you're actually doing is getting a filtered **sub-list** of the elements that have those indices, just as single brackets on a vector return a subset of elements in that vector:

```r
my_list <- list('A', 201, TRUE, 'rhinoceros')

# SINGLE brackets returns a list
my_list[1]
            # [[1]]
            # [1] "A"

# DOUBLE brackets returns a vector
my_list[[1]]  # [1] "A"

# can use any vector as the argument to single brackets, just like with vectors
my_list[1:3]
            # [[1]]
            # [1] "A"
            #
            # [[2]]
            # [1] 201
            #
            # [[3]]
            # [1] TRUE
```

In sum, remember that **single-brackets gives a list, double-brackets gives a list element**. You almost always want to be refering to the value itself (the vector&mdash;everything is a vector!) rather than a list, so almost always want to use ___double-brackets___ when accessing lists.


### Extracting named elements with `$`

If you printed out the above `person` list, you would see the following:

```
> print(person)
$first_name
[1] "Ada"

$job
[1] "Programmer"

$salary
[1] 78000

$in_union
[1] TRUE
```

Notice that the output lists each tag name prepended with a dollar sign
(**`$`**) symbol, and then on the following line the vector that is the
element itself. The `$` symbol is one of the easiest ways of accessing
list elements.  There are no analogue for atomic vectors, even for named
vectors.  `$` extractor only exists for lists (and such data structures
that are derived from lists like data frames).

Because list elements are (usually) tagged, you can access them by their tag name rather than by the index number you used with vectors. You do this by using **dollar notation**: you refer to the element with a particular tag in a list by writing the name of the list, followed by a `$`, followed by the element's tag:

```r
person <- list(first_name = "Ada", job = "Programmer", salary = 78000, in_union = TRUE)

person$first_name  # [1] "Ada"
person$salary  # [1] 78000
```

(See below for other options for accessing list elements).

You can almost read the dollar sign as like an "apostrophe s" (possessive) in English: so `person$salary` would mean "the `person` list**'s** `salary` value".

Dollar notation allows list elements to almost be treated as variables in their own right&mdash;for example, you specify that you're talking about the `salary` variable in the `person` list, rather than the `salary` variable in some other list (or not in a list at all).

```r
person <- list(first_name = "Ada", job = "Programmer", salary = 78000, in_union = TRUE)

# use elements as function or operation arguments
paste(person$job, person$first_name)   # [1] "Programmer Ada"

# assign values to list element
person$job <- "Senior Programmer"  # a promotion!
print(person$job)  # [1] "Senior Programmer"

# assign value to list element from itself
person$salary <- person$salary * 1.15  # a 15% raise!
print(person$salary)  # [1] 89700
```

Note that if you need to, you can get a _vector_ of element tags using the `names()` function:

```r
person <- list(first_name = "Ada", job = "Programmer", salary = 78000, in_union = TRUE)
names(person)  # [1] "first_name" "job"  "salary"  "in_union"
```

- This is useful for understanding the structure of variables that may have come from other data sources.


name_to_use <- "last_name"  # choose name (i.e., based on formality)
person[[name_to_use]]  # [1] "Wong"
name_to_use <- "first_name"  # change name to use
person[[name_to_use]]  # [1] "Bob"

You can also use double-bracket notation to access an element by its tag if you put a character string (in `""`) of the tag name inside the brackets. This is particularly useful if you want the tag itself to be a variable!

### Modifying Lists
Similarly to vectors, you can add and modify list elements. However, lists also enable you to _remove_ elements.

You can add elements to a list simply by assigning a value to a tag (or index) in the list that doesn't yet exist:

```r
person <- list(first_name = "Ada", job = "Programmer", salary = 78000, in_union = TRUE)

# has no `age` element
person$age  # NULL

# assign a value to the `age` tag to add it
person$age <- 40
person$age  # [1] 40

# assign using index
person[[10]] <- "Tenth field"
# elements 6-9 will be NULL
```

You can also remove elements by assiging the special value `NULL` to their tag or index:

```r
a_list <- list('A', 201, True)
a_list[[2]] <- NULL  # remove element #2
print(a_list)
            # [[1]]
            # [1] "A"
            #
            # [[2]]
            # [1] TRUE
```




## The `lapply()` Function
Since everything is a vector in R, and most functions are _vectorized_, you can can pass most functions (e.g., `paste()`, `round()`, etc.) a vector as an argument and the function will be applied to each item in the vector. It "just works". But if you want to apply a function to each item in a _list_, you need to put in a bit more effort.

In particular, you need to use a function called **`lapply()`** (for _**l**ist apply_). This function takes two arguments: the first is a list or vector you want to modify, and the second is a function you want to "apply" to each item in that list. For example:

```r
# list, not a vector
people <- list("Sarah", "Amit", "Zhang")

# apply the `toupper()` function to each element in `people`
people_upper <- lapply(people, toupper)
            # [[1]]
            # [1] "SARAH"
            #
            # [[2]]
            # [1] "AMIT"
            #
            # [[3]]
            # [1] "ZHANG"

# apply the `paste()` function to each element in `people`,
# with an addition argument `"dances!"` to each call
dance_party <- lapply(people, paste, "dances!")
```

- Notice that the second argument to `lapply()` is just the name of the function: not a character string (it's not in `""`). You're also not actually _calling_ that function (there are no `()` after it). Just put the name of the function! After that, you can put any additional arguments you want the applied function to be called with: for example, how many digits to round to, or what value to paste to the end of a string.

Note that the `lapply()` function returns a _new_ list; the original one is unmodified (though if the list contains vectors or other lists as elements, it's possible for those values to be changed). This makes it a **mapping** operation (applied to the maps that are lists).

You commonly use `lapply()` with your own custom functions which define what you want to do to a single element in that list:

```r
# A function that prepends "Hello" to any item
greet <- function(item) {
  return(paste("Hello", item))
}

# a list of people
people <- list("Sarah", "Amit", "Zhang")

# greet each name
greetings <- lapply(people, greet)
            # [[1]]
            # [1] "Hello Sarah"
            #
            # [[2]]
            # [1] "Hello Amit"

            # [[3]]
            # [1] "Hello Zhang"
```

Additionally, `lapply()` is a member of the "`*apply()`" family of functions: a set of functions that each start with a different letter and applies to a different data structure, but otherwise all work basically the same. For example, `lapply()` is used for lists, while `sapply()` (**s**implified apply) works well for vectors.

## Resources {-}
- [R Tutorial: Lists](http://www.r-tutor.com/r-introduction/list)
- [R Tutorial: Named List Members](http://www.r-tutor.com/r-introduction/list/named-list-members)
- [StackOverflow: Single vs. double brackets](http://stackoverflow.com/questions/1169456/in-r-what-is-the-difference-between-the-and-notations-for-accessing-the)
